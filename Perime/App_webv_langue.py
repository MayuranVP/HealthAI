import streamlit as st
import speech_recognition as sr
from gtts import gTTS
import pygame
import tempfile
import time
import pandas as pd
from datetime import datetime
import os
from io import BytesIO

# Traductions multilingues
translations = {
    "fr": {
        "title": "üß† Simulateur ACLS Vocal Interactif",
        "start": "‚ñ∂Ô∏è Lancer la simulation",
        "stop": "üõë Stopper la simulation",
        "speak_now": " Parlez maintenant (oui ou non)...",
        "said": " Vous avez dit :",
        "no_sound": "‚è± Aucun son d√©tect√© dans le temps imparti.",
        "not_understood": " R√©ponse non comprise.",
        "end_algo": " Fin de l'algorithme ACLS",
        "export": "üì§ Exporter le rapport de simulation",
        "download": "üì• T√©l√©charger le rapport Excel",
        "time_left": "‚è≥ Temps restant :",
        "time_over": "‚è±Ô∏è Temps √©coul√©.",
        "stopped": "üö® Simulation interrompue.",
        "yes": "oui",
        "no": "non",
        "rcp_start": "D√©but de la RCP. Connexion de l'oxyg√®ne et du d√©fibrillateur",
        "shock1": " CHOC 1 d√©livr√©",
        "shock2": " CHOC 2",
        "shock3": " CHOC 3",
        "shock_conv": " CHOC sur rythme devenu choquable",
        "epi": " √âpin√©phrine administr√©e",
        "epi_alone": " √âpin√©phrine seule + RCP",
        "epi_now": " √âpin√©phrine IMM√âDIATE",
        "amio": " Amiodarone/Lidoca√Øne + causes r√©versibles",
        "rcp_cause": " RCP 2 min + Causes r√©versibles",
        "rcp_loop": "üîÅ Continuer RCP / choc / m√©dicaments",
        "rosc_reached": "‚úÖ ROSC atteint ‚Üí soins post-arr√™t",
        "prompt_rhythm": "Le rythme est-il choquable ?",
        "prompt_rhythm2": "Le rythme est-il encore choquable ?",
        "prompt_rhythm3": "Encore choquable ?",
        "prompt_nonshock1": "Le rythme est-il devenu choquable ?",
        "prompt_nonshock2": "Le rythme est-il devenu choquable ?",
        "prompt_rosc": "Y a-t-il un retour de circulation spontan√©e ?"
    },
    "en": {
        "title": "üß† Interactive ACLS Voice Simulator",
        "start": "‚ñ∂Ô∏è Start Simulation",
        "stop": "üõë Stop Simulation",
        "speak_now": "üéôÔ∏è Speak now (yes or no)...",
        "said": "üó£Ô∏è You said:",
        "no_sound": "‚è±Ô∏è No sound detected in time.",
        "not_understood": "ü§î Response not understood.",
        "end_algo": "üèÅ End of ACLS algorithm",
        "export": "üì§ Export simulation report",
        "download": "üì• Download Excel report",
        "time_left": "‚è≥ Time left:",
        "time_over": "‚è±Ô∏è Time's up.",
        "stopped": "üö® Simulation stopped.",
        "yes": "yes",
        "no": "no",
        "rcp_start": "Start CPR. Connect oxygen and defibrillator",
        "shock1": " SHOCK #1 delivered",
        "shock2": " SHOCK #2",
        "shock3": " SHOCK #3",
        "shock_conv": " SHOCK on converted rhythm",
        "epi": " Epinephrine administered",
        "epi_alone": " Epinephrine only + CPR",
        "epi_now": " IMMEDIATE Epinephrine",
        "amio": " Amiodarone/Lidocaine + reversible causes",
        "rcp_cause": " CPR 2 min + Reversible causes",
        "rcp_loop": " Continue CPR / shock / meds",
        "rosc_reached": " ROSC achieved ‚Üí post-cardiac care",
        "prompt_rhythm": "Is the rhythm shockable?",
        "prompt_rhythm2": "Is the rhythm still shockable?",
        "prompt_rhythm3": "Still shockable?",
        "prompt_nonshock1": "Has the rhythm become shockable?",
        "prompt_nonshock2": "Has the rhythm become shockable?",
        "prompt_rosc": "Is there a return of spontaneous circulation?"
    },
    "th": {
        "title": "üß† ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏à‡∏≥‡∏•‡∏≠‡∏á ACLS ‡πÅ‡∏ö‡∏ö‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏á",
        "start": "‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á",
        "stop": "üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á",
        "speak_now": " ‡∏û‡∏π‡∏î‡πÄ‡∏•‡∏¢ (‡πÉ‡∏ä‡πà ‡∏´‡∏£‡∏∑‡∏≠ ‡πÑ‡∏°‡πà)...",
        "said": " ‡∏Ñ‡∏∏‡∏ì‡∏û‡∏π‡∏î‡∏ß‡πà‡∏≤:",
        "no_sound": "‚è± ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÉ‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î",
        "not_understood": " ‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö",
        "end_algo": " ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô ACLS",
        "export": "üì§ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á",
        "download": "üì• ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô Excel",
        "time_left": " ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠:",
        "time_over": "‚è± ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤",
        "stopped": " ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏≥‡∏•‡∏≠‡∏á",
        "yes": "‡πÉ‡∏ä‡πà",
        "no": "‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà",
        "rcp_start": "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏≠‡∏Å ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏ã‡∏¥‡πÄ‡∏à‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ä‡πá‡∏≠‡∏Å‡πÑ‡∏ü‡∏ü‡πâ‡∏≤",
        "shock1": " ‡∏ä‡πá‡∏≠‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà 1",
        "shock2": " ‡∏ä‡πá‡∏≠‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà 2",
        "shock3": " ‡∏ä‡πá‡∏≠‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà 3",
        "shock_conv": " ‡∏ä‡πá‡∏≠‡∏Å‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏ó‡∏µ‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤",
        "epi": " ‡πÉ‡∏´‡πâ‡∏¢‡∏≤‡∏≠‡∏¥‡∏û‡∏¥‡πÄ‡∏ô‡∏ü‡∏£‡∏¥‡∏ô",
        "epi_alone": " ‡πÉ‡∏´‡πâ‡∏¢‡∏≤‡∏≠‡∏¥‡∏û‡∏¥‡πÄ‡∏ô‡∏ü‡∏£‡∏¥‡∏ô + ‡∏ó‡∏≥ CPR",
        "epi_now": " ‡πÉ‡∏´‡πâ‡∏¢‡∏≤‡∏≠‡∏¥‡∏û‡∏¥‡πÄ‡∏ô‡∏ü‡∏£‡∏¥‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ",
        "amio": " ‡∏¢‡∏≤ Amiodarone/Lidocaine + ‡∏´‡∏≤‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ",
        "rcp_cause": "üîÑ ‡∏ó‡∏≥ CPR + ‡∏´‡∏≤‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ",
        "rcp_loop": "üîÅ ‡∏ó‡∏≥ CPR / ‡∏ä‡πá‡∏≠‡∏Å / ‡πÉ‡∏´‡πâ‡∏¢‡∏≤ ‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á",
        "rosc_reached": "‚úÖ ROSC ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Üí ‡∏î‡∏π‡πÅ‡∏•‡∏´‡∏•‡∏±‡∏á‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏ï‡πâ‡∏ô",
        "prompt_rhythm": "‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ä‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?",
        "prompt_rhythm2": "‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡∏¢‡∏±‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ä‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?",
        "prompt_rhythm3": "‡∏¢‡∏±‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ä‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏≠‡∏µ‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?",
        "prompt_nonshock1": "‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ä‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?",
        "prompt_nonshock2": "‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ä‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?",
        "prompt_rosc": "‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÑ‡∏´‡∏•‡πÄ‡∏ß‡∏µ‡∏¢‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏î‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?"
    }
}

# S√©lecteur de langue dans la sidebar
st.sidebar.title("üåê Langue / Language / ‡∏†‡∏≤‡∏©‡∏≤")
lang = st.sidebar.selectbox("Choisissez la langue", options=["fr", "en", "th"], format_func=lambda l: {"fr": "Fran√ßais üá´üá∑", "en": "English üá¨üáß", "th": "‡πÑ‡∏ó‡∏¢ üáπüá≠"}[l])
T = translations[lang]

# Synth√®se vocale avec gTTS + pygame
def speak(text):
    try:
        tts = gTTS(text=text, lang=lang)
        temp_path = os.path.join(tempfile.gettempdir(), "temp_audio.mp3")
        tts.save(temp_path)
        pygame.mixer.init()
        pygame.mixer.music.load(temp_path)
        pygame.mixer.music.play()
        while pygame.mixer.music.get_busy():
            time.sleep(0.1)
        pygame.mixer.music.unload()
        os.remove(temp_path)
    except Exception as e:
        st.warning(f"Erreur de synth√®se vocale : {e}")

# Session
if "event_log" not in st.session_state:
    st.session_state.event_log = []
if "arret_demande" not in st.session_state:
    st.session_state.arret_demande = False
if "procedure_terminee" not in st.session_state:
    st.session_state.procedure_terminee = False

def log_event(message):
    timestamp = datetime.now().strftime("%H:%M:%S")
    st.markdown(f"üïí `{timestamp}` - {message}")
    speak(message)
    st.session_state.event_log.append({"Horodatage": timestamp, "√âv√©nement": message})

def listen():
    recognizer = sr.Recognizer()
    recognizer.energy_threshold = 300
    recognizer.pause_threshold = 0.8
    recognizer.non_speaking_duration = 0.5
    with sr.Microphone() as source:
        st.write(T["speak_now"])
        try:
            audio = recognizer.listen(source, timeout=6, phrase_time_limit=5)
            response = recognizer.recognize_google(audio, language={"fr": "fr-FR", "en": "en-US", "th": "th-TH"}[lang])
            st.success(f"{T['said']} {response}")
            return response.lower()
        except sr.WaitTimeoutError:
            st.warning(T["no_sound"])
        except sr.UnknownValueError:
            st.warning(T["not_understood"])
        except sr.RequestError as e:
            st.error(f"Speech API error: {e}")
        return None

def ask_question(question_text_key, retry=3):
    log_event(T[question_text_key])
    for _ in range(retry):
        if st.session_state.arret_demande:
            log_event(T["stopped"])
            return -1
        response = listen()
        if response:
            if T["yes"] in response:
                return 1
            elif T["no"] in response:
                return 0
    log_event("‚ùå " + T["not_understood"])
    return -1

def countdown(seconds, message):
    placeholder = st.empty()
    for remaining in range(seconds, 0, -1):
        if st.session_state.arret_demande:
            placeholder.warning(T["stopped"])
            return
        placeholder.markdown(
            f"<h1 style='text-align: center; color: #FF4B4B;'>{message} {remaining} sec</h1>",
            unsafe_allow_html=True
        )
        time.sleep(1)
    placeholder.success(T["time_over"])

def step_safe(message_key):
    if st.session_state.arret_demande:
        log_event(T["stopped"])
        return False
    log_event(T[message_key])
    return True

def export_log_to_excel():
    df = pd.DataFrame(st.session_state.event_log)
    buffer = BytesIO()
    df.to_excel(buffer, index=False, engine='openpyxl')
    buffer.seek(0)
    return buffer

def generate_filename():
    today = datetime.now().strftime("%Y-%m-%d")
    base_name = f"ACLS_{lang}_{today}"
    counter = 1
    while True:
        filename = f"{base_name}_{counter:03d}.xlsx"
        if not os.path.exists(filename):
            return filename
        counter += 1



def run_acls():
    st.title(T["title"])

    if st.button(T["stop"]):
        st.session_state.arret_demande = True

    if st.button(T["start"]):
        st.session_state.event_log.clear()
        st.session_state.arret_demande = False
        st.session_state.procedure_terminee = False

        if not step_safe("rcp_start"):
            return

        shockable = ask_question("prompt_rhythm")

        if shockable == 1:
            if not step_safe("shock1"):
                return
            countdown(120, T["time_left"])
            shockable = ask_question("prompt_rhythm2")

            if shockable == 1:
                if not step_safe("shock2"):
                    return
                if not step_safe("epi"):
                    return
                countdown(120, T["time_left"])
                shockable = ask_question("prompt_rhythm3")

                if shockable == 1:
                    if not step_safe("shock3"):
                        return
                    if not step_safe("amio"):
                        return
                    countdown(120, T["time_left"])
                else:
                    if not step_safe("rcp_cause"):
                        return
                    countdown(120, T["time_left"])
            else:
                if not step_safe("epi_alone"):
                    return
                countdown(120, T["time_left"])

        elif shockable == 0:
            if not step_safe("epi_now"):
                return
            countdown(120, T["time_left"])
            shockable = ask_question("prompt_nonshock1")

            if shockable == 1:
                if not step_safe("shock_conv"):
                    return
                countdown(120, T["time_left"])
            else:
                if not step_safe("rcp_cause"):
                    return
                countdown(120, T["time_left"])
                shockable = ask_question("prompt_nonshock2")
                if shockable == 1:
                    if not step_safe("shock3"):
                        return
                    countdown(120, T["time_left"])

        rosccheck = ask_question("prompt_rosc")
        if rosccheck == 1:
            step_safe("rosc_reached")
        else:
            step_safe("rcp_loop")

        log_event(T["end_algo"])
        st.session_state.procedure_terminee = True

    if st.session_state.event_log:
        st.markdown("---")
        st.markdown(f"## {T['export']}")
        buffer = export_log_to_excel()
        filename = generate_filename()
        st.download_button(
            label=T["download"],
            data=buffer,
            file_name=filename,
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

run_acls()
